<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro Neko</title>
    <link rel="icon" href="images/favicon.png" type="image/png">
    <link rel="stylesheet" href="style/index.css">
</head>
<body>
    <header>
        <div class="header-left">
            <img src="images/favicon1.png" alt="logo">
            <h1>AstroNeko</h1>
        </div>

        <div class="search-container">
            <input type="text" id="search" placeholder="Пошук аніме...">
            <button id="surprise">Здивуй мене</button>
        </div>
    </header>

    <main>
        <!-- Контейнер для всіх контролів -->
        <div class="controls-container">
            <div class="filters-section">
                <select class="filter-select" id="genre-filter">
                    <option value="">Всі жанри</option>
                </select>
                
                <select class="filter-select" id="status-filter">
                    <option value="">Всі статуси</option>
                    <option value="Онґоїнг">Онґоїнг</option>
                    <option value="Завершено">Завершено</option>
                    <option value="Анонс">Анонс</option>
                </select>
                
                <select class="filter-select" id="year-filter">
                    <option value="">Всі роки</option>
                </select>
            </div>
            
            <div class="sort-section">
                <div class="sort-container">
                  <button class="sort-order" id="sort-order" data-order="asc">↑</button>
                    <select class="sort-select" id="sort-by">
                        <option value="title">Назва</option>
                        <option value="rating">Рейтинг</option>
                        <option value="episodes">Серії</option>
                        <option value="year">Рік</option>
                    </select>
                </div>
                
                <select class="view-select" id="view-select">
                    <option value="grid">Сітка</option>
                    <option value="compact">Компактно</option>
                    <option value="list">Список</option>
                </select>
            </div>
        </div>
        
        <!-- Сітка аніме -->
        <div class="anime-grid" id="anime-grid">
            <!-- Картки аніме будуть згенеровані тут -->
        </div>
        
        <!-- Список аніме -->
        <div class="anime-list" id="anime-list">
            <!-- Елементи списку будуть згенеровані тут -->
        </div>
        
        <div class="loading-indicator" id="loading" style="display:none;">
            <div class="loading-spinner"></div> Завантаження...
        </div>
    </main>

    <script>
        let animeList = [];
        let loadedAnimeData = [];
        let loadedCount = 0;
        const batchSize = 20;
        let currentFlippedCard = null;
        
        // Налаштування з localStorage
        let sortSettings = JSON.parse(localStorage.getItem('sortSettings')) || {
            by: 'title',
            order: 'asc'
        };
        
        let viewSettings = JSON.parse(localStorage.getItem('viewSettings')) || {
            view: 'grid'
        };

        // Функція для підрахунку загальної кількості серій
        function calculateTotalEpisodes(anime) {
            let total = 0;
            
            if (anime.seasons && Array.isArray(anime.seasons)) {
                anime.seasons.forEach(season => {
                    if (season.episodes && Array.isArray(season.episodes)) {
                        total += season.episodes.length;
                    }
                });
            }
            
            if (anime.movies && Array.isArray(anime.movies)) {
                total += anime.movies.length;
            }
            
            return total > 0 ? total : 0;
        }

        function calculateTotalSeasons(anime) {
            if (anime.seasons && Array.isArray(anime.seasons)) {
                return anime.seasons.length;
            }
            return 0;
        }

        function getReleaseYear(anime) {
            if (anime.seasons && anime.seasons.length > 0 && anime.seasons[0].year) {
                return parseInt(anime.seasons[0].year);
            }
            return 0;
        }

        function getRating(anime) {
            if (anime.rating && typeof anime.rating === 'string') {
                const match = anime.rating.match(/(\d+\.?\d?)/);
                return match ? parseFloat(match[1]) : 0;
            }
            return 0;
        }

        function sortAnimeData(animeData) {
            return [...animeData].sort((a, b) => {
                let aValue, bValue;
                
                switch (sortSettings.by) {
                    case 'title':
                        aValue = a.title || '';
                        bValue = b.title || '';
                        break;
                    case 'rating':
                        aValue = getRating(a);
                        bValue = getRating(b);
                        break;
                    case 'episodes':
                        aValue = calculateTotalEpisodes(a);
                        bValue = calculateTotalEpisodes(b);
                        break;
                    case 'year':
                        aValue = getReleaseYear(a);
                        bValue = getReleaseYear(b);
                        break;
                    default:
                        aValue = a.title || '';
                        bValue = b.title || '';
                }
                
                if (typeof aValue === 'string') {
                    aValue = aValue.toLowerCase();
                    bValue = bValue.toLowerCase();
                }
                
                let result = 0;
                if (aValue < bValue) result = -1;
                if (aValue > bValue) result = 1;
                
                return sortSettings.order === 'desc' ? -result : result;
            });
        }

        function filterAnimeData(animeData) {
            const genreFilter = document.getElementById('genre-filter').value;
            const statusFilter = document.getElementById('status-filter').value;
            const yearFilter = document.getElementById('year-filter').value;
            
            return animeData.filter(anime => {
                if (genreFilter && (!anime.tags || !anime.tags.includes(genreFilter))) {
                    return false;
                }
                
                if (statusFilter && anime.status !== statusFilter) {
                    return false;
                }
                
                if (yearFilter) {
                    const year = getReleaseYear(anime);
                    if (year !== parseInt(yearFilter)) {
                        return false;
                    }
                }
                
                return true;
            });
        }

        function updateDisplay() {
            const grid = document.getElementById('anime-grid');
            const list = document.getElementById('anime-list');
            
            grid.innerHTML = '';
            list.innerHTML = '';
            
            const filteredData = filterAnimeData(loadedAnimeData);
            const sortedData = sortAnimeData(filteredData);
            
            if (sortedData.length === 0) {
                showNoResultsMessage(true);
                return;
            }
            
            showNoResultsMessage(false);
            
            sortedData.forEach(anime => {
                grid.appendChild(createAnimeCard(anime));
                list.appendChild(createAnimeListItem(anime));
            });
            
            changeView(viewSettings.view);
        }

        function createAnimeCard(anime) {
            const card = document.createElement('div');
            card.classList.add('anime-card');

            const front = document.createElement('div');
            front.classList.add('front');
            front.innerHTML = `
              <div class="image-container">
                <img src="${anime.img || 'N/A'}" alt="${anime.title || 'N/A'}" onerror="this.src='https://via.placeholder.com/300x450?text=No+Image'">
              </div>
              <div class="title-container">
                <h3>${anime.title || 'N/A'}</h3>
              </div>`;

            const totalEpisodes = calculateTotalEpisodes(anime);
            const totalSeasons = calculateTotalSeasons(anime);
            
            const back = document.createElement('div');
            back.classList.add('back');
            back.innerHTML = `
                <div class="back-content">
                    <h4>${anime.title || 'N/A'}</h4>
                    <div class="back-info">
                        <p><strong>Серії:</strong> ${totalEpisodes}</p>
                        <p><strong>Сезони:</strong> ${totalSeasons}</p>
                        <p><strong>Рейтинг:</strong> ${anime.rating || 'N/A'}</p>
                        <p><strong>Жанри:</strong> ${anime.tags && anime.tags.length > 0 ? anime.tags.join(', ') : 'N/A'}</p>
                    </div>
                    <button class="details-btn">Детальніше</button>
                </div>
            `;
            
            back.querySelector('button').onclick = (e) => {
                e.stopPropagation();
                window.location.href = `anime-info.html?id=${encodeURIComponent(anime.id)}`;
            };

            card.appendChild(front);
            card.appendChild(back);
            
            card.onclick = (e) => {
                if (e.target.classList.contains('details-btn')) {
                    return;
                }
                
                if (currentFlippedCard && currentFlippedCard !== card) {
                    currentFlippedCard.classList.remove('flipped');
                }
                
                card.classList.toggle('flipped');
                
                if (card.classList.contains('flipped')) {
                    currentFlippedCard = card;
                } else {
                    currentFlippedCard = null;
                }
            };

            return card;
        }

        function createAnimeListItem(anime) {
            const item = document.createElement('div');
            item.classList.add('anime-list-item');

            const totalEpisodes = calculateTotalEpisodes(anime);
            const totalSeasons = calculateTotalSeasons(anime);
            const year = getReleaseYear(anime);

            item.innerHTML = `
                <img class="list-item-image" src="${anime.img || 'N/A'}" alt="${anime.title || 'N/A'}" onerror="this.src='https://via.placeholder.com/300x450?text=No+Image'">
                <div class="list-item-content">
                    <h3 class="list-item-title">${anime.title || 'N/A'}</h3>
                    <div class="list-item-meta">
                        <span><strong>Серії:</strong> ${totalEpisodes}</span>
                        <span><strong>Сезони:</strong> ${totalSeasons}</span>
                        <span><strong>Рейтинг:</strong> ${anime.rating || 'N/A'}</span>
                        <span><strong>Рік:</strong> ${year || 'N/A'}</span>
                    </div>
                    <div class="list-item-tags">
                        ${anime.tags && anime.tags.length > 0 ? anime.tags.join(', ') : 'N/A'}
                    </div>
                    <div class="list-item-actions">
                        <button class="list-details-btn">Детальніше</button>
                    </div>
                </div>
            `;
            
            item.querySelector('.list-details-btn').onclick = () => {
                window.location.href = `anime-info.html?id=${encodeURIComponent(anime.id)}`;
            };

            return item;
        }

        async function loadAnimeList() {
            try {
                const resp = await fetch('anime/anime-list.json');
                if (!resp.ok) throw new Error('Не вдалося завантажити anime-list.json');
                animeList = await resp.json();
                loadNextBatch();
            } catch (err) {
                console.error('Помилка при завантаженні списку аніме:', err);
            }
        }

        async function loadNextBatch() {
            if (loadedCount >= animeList.length) return;

            const loadingText = document.getElementById('loading');
            loadingText.style.display = 'block';
            
            const nextBatch = animeList.slice(loadedCount, loadedCount + batchSize);

            for (const animeId of nextBatch) {
                try {
                    const resp = await fetch(`anime/${encodeURIComponent(animeId)}.json`);
                    if (!resp.ok) continue;
                    const anime = await resp.json();
                    loadedAnimeData.push(anime);
                    updateFilters(anime);
                } catch (err) {
                    console.error(`Не вдалося завантажити ${animeId}.json`, err);
                }
            }

            loadedCount += nextBatch.length;
            loadingText.style.display = 'none';
            
            updateDisplay();
        }

        function updateFilters(anime) {
            const genreFilter = document.getElementById('genre-filter');
            const yearFilter = document.getElementById('year-filter');
            
            if (anime.tags) {
                anime.tags.forEach(tag => {
                    if (![...genreFilter.options].some(opt => opt.value === tag)) {
                        const option = document.createElement('option');
                        option.value = tag;
                        option.textContent = tag;
                        genreFilter.appendChild(option);
                    }
                });
            }
            
            const year = getReleaseYear(anime);
            if (year > 0 && ![...yearFilter.options].some(opt => opt.value === year.toString())) {
                const option = document.createElement('option');
                option.value = year.toString();
                option.textContent = year.toString();
                yearFilter.appendChild(option);
            }
        }

        function showNoResultsMessage(show) {
            let message = document.getElementById('no-results-message');
            
            if (show && !message) {
                message = document.createElement('div');
                message.id = 'no-results-message';
                message.classList.add('no-results');
                message.textContent = 'За вашим запитом нічого не знайдено. Спробуйте змінити фільтри.';
                
                const grid = document.getElementById('anime-grid');
                grid.appendChild(message);
            } else if (!show && message) {
                message.remove();
            }
        }

        function changeView(view) {
            viewSettings.view = view;
            localStorage.setItem('viewSettings', JSON.stringify(viewSettings));
            
            const grid = document.getElementById('anime-grid');
            const list = document.getElementById('anime-list');
            const viewSelect = document.getElementById('view-select');
            
            viewSelect.value = view;
            
            if (view === 'list') {
                grid.style.display = 'none';
                list.style.display = 'flex';
            } else {
                grid.style.display = 'grid';
                list.style.display = 'none';
                grid.classList.toggle('compact', view === 'compact');
            }
        }

        function saveSortSettings() {
            localStorage.setItem('sortSettings', JSON.stringify(sortSettings));
        }

        function initializeUI() {
            document.getElementById('sort-by').value = sortSettings.by;
            document.getElementById('sort-order').textContent = sortSettings.order === 'asc' ? '↑' : '↓';
            document.getElementById('sort-order').dataset.order = sortSettings.order;
            
            changeView(viewSettings.view);
        }

        // Обробники подій
        document.getElementById('sort-by').addEventListener('change', (e) => {
            sortSettings.by = e.target.value;
            saveSortSettings();
            updateDisplay();
        });
        
        document.getElementById('sort-order').addEventListener('click', () => {
            sortSettings.order = sortSettings.order === 'asc' ? 'desc' : 'asc';
            document.getElementById('sort-order').textContent = sortSettings.order === 'asc' ? '↑' : '↓';
            document.getElementById('sort-order').dataset.order = sortSettings.order;
            saveSortSettings();
            updateDisplay();
        });
        
        document.getElementById('view-select').addEventListener('change', (e) => {
            changeView(e.target.value);
        });
        
        document.getElementById('genre-filter').addEventListener('change', () => {
            updateDisplay();
        });
        
        document.getElementById('status-filter').addEventListener('change', () => {
            updateDisplay();
        });
        
        document.getElementById('year-filter').addEventListener('change', () => {
            updateDisplay();
        });

        document.getElementById('search').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            document.querySelectorAll('.anime-card, .anime-list-item').forEach(item => {
                const title = item.querySelector('h3').textContent.toLowerCase();
                item.style.display = title.includes(query) ? '' : 'none';
            });
        });

        document.getElementById('surprise').addEventListener('click', () => {
            if (loadedAnimeData.length === 0) return;
            const filteredData = filterAnimeData(loadedAnimeData);
            if (filteredData.length === 0) return;
            const randomAnime = filteredData[Math.floor(Math.random() * filteredData.length)];
            window.location.href = `anime-info.html?id=${encodeURIComponent(randomAnime.id)}`;
        });

        window.addEventListener('scroll', () => {
            if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
                loadNextBatch();
            }
        });

        document.addEventListener('click', (e) => {
            if (currentFlippedCard && !currentFlippedCard.contains(e.target)) {
                currentFlippedCard.classList.remove('flipped');
                currentFlippedCard = null;
            }
        });

        // Auto-hide header
        let lastScrollY = window.scrollY;
        const header = document.querySelector('header');
        const headerHeight = header.offsetHeight;

        document.querySelector('main').style.paddingTop = headerHeight + 'px';

        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            
            if (currentScrollY > lastScrollY && currentScrollY > headerHeight) {
                header.classList.add('hidden');
            } else {
                header.classList.remove('hidden');
            }
            
            lastScrollY = currentScrollY;
        });

        header.addEventListener('mouseenter', () => {
            header.classList.remove('hidden');
        });

        header.addEventListener('mouseleave', () => {
            lastScrollY = window.scrollY;
        });

        // Ініціалізація
        loadAnimeList();
        initializeUI();
    </script>
</body>
</html>